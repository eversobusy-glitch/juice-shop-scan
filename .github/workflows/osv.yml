# .github/workflows/osv.yml
name: OSV Scanner (SCA)  # Workflow name visible in Actions UI

on:
  push:                        # Trigger on pushes to these branches
    branches: [ master, main ]
  pull_request:                # And on pull requests targeting these branches

jobs:
  osv-scanner:                 # Single job for SCA scanning
    runs-on: ubuntu-latest     # GitHub-hosted Ubuntu runner

    steps:
      # 1) Checkout repository contents
      - name: Checkout
        uses: actions/checkout@v4

      # 2) Prepare Node runtime (we only need it to create a lockfile)
      - name: Setup Node.js (LTS 18)
        uses: actions/setup-node@v4
        with:
          node-version: 18

      # 3) Generate a lockfile *without* running package post-install scripts
      - name: Generate package-lock.json (safe)
        run: npm install --package-lock-only --ignore-scripts

      # 4) Install jq (we use it to parse/format OSV JSON)
      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      # 5) Install OSV-Scanner (static binary)
      - name: Install OSV-Scanner
        run: |
          curl -sSfL https://github.com/google/osv-scanner/releases/latest/download/osv-scanner_linux_amd64 -o osv-scanner
          chmod +x osv-scanner
          sudo mv osv-scanner /usr/local/bin/osv-scanner

      # 6) Run OSV against the lockfile; keep raw + cleaned JSON
      - name: Run OSV-Scanner -> JSON
        run: |
          set -e
          # Do not fail the job on findings; we’ll handle gating separately if needed
          osv-scanner --lockfile=package-lock.json --format json > osv-results.json || true
          # Remove long package paths to keep the summary readable
          jq 'del(.results[]?.packages[]?.package_path)' osv-results.json > osv-results-clean.json

      # 7) Upload artifacts so reviewers can download the full data
      - name: Upload OSV results (raw + cleaned)
        uses: actions/upload-artifact@v4
        with:
          name: osv-results
          path: |
            osv-results.json
            osv-results-clean.json
          if-no-files-found: warn

      # 8) Append a readable summary to the job page:
      #    - Critical CVEs table
      #    - All CVEs ordered by severity
      #    - Optional grouped-by-package view (collapsible)
      - name: Add CVE list to job summary (Critical, All ordered, Grouped)
        shell: bash
        run: |
          set -eo pipefail

          echo "## OSV Scanner — Summary" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

          # Write the jq program to a file using a *literal* heredoc to avoid YAML/Bash quoting issues.
          cat > jq_prog.jq <<'JQ'
          def cvss_num:
            (.severity[]?.score // empty
             | capture("(?<num>[0-9]+\\.[0-9]+)")?.num // empty
             | tonumber?);

          def sev_label:
            (.database_specific.severity // (.severity[]?.score // "") | ascii_upcase) as $s
            | if   ($s | test("CRITICAL")) then "CRITICAL"
              elif ($s | test("HIGH"))     then "HIGH"
              elif ($s | test("MODERATE|MEDIUM")) then "MEDIUM"
              elif ($s | test("LOW"))      then "LOW"
              else
                (cvss_num as $n
                 | if   ($n>=9) then "CRITICAL"
                   elif ($n>=7) then "HIGH"
                   elif ($n>=4) then "MEDIUM"
                   elif ($n>0) then "LOW"
                   else "n/a" end)
              end;

          def rank($l):
            if   $l=="CRITICAL" then 4
            elif $l=="HIGH"     then 3
            elif $l=="MEDIUM"   then 2
            elif $l=="LOW"      then 1
            else 0 end;

          # Prefer a CVE alias; otherwise use advisory ID (GHSA/OSV)
          def cve: ((.aliases[]? | select(startswith("CVE-"))) // .id // "n/a");

          # Try to extract a fixed version from common locations
          def fixed:
            (.fixedVersion // (.affected[]?.ranges[]?.events[]? | select(has("fixed")) | .fixed) // "n/a");

          [ .results[]?
            | .packages[]? as $p
            | ($p.package.name // "n/a") as $pkg
            | ($p.package.version // "n/a") as $ver
            | $p.vulnerabilities[]?
            | { pkg:   $pkg,
                ver:   $ver,
                cve:   (cve),
                sev:   (sev_label),
                fixed: (fixed) } ] as $rows
          | $rows
          | map(. + { rank: (rank(.sev)) })
          JQ

          # Normalize all rows once
          rows_json="$(jq -c -f jq_prog.jq osv-results.json || true)"
          if [ -z "$rows_json" ] || [ "$rows_json" = "null" ]; then
            echo "_No results parsed._" >> "$GITHUB_STEP_SUMMARY"
            exit 0
          fi

          # KPIs line (quick glance)
          kpis="$(printf '%s\n' "$rows_json" | jq -r '
            def cnt($l): map(select(.sev==$l)) | length;
            . as $r
            | "Total vulns: \(\$r|length)  |  Critical: \(\$r|cnt(\"CRITICAL\"))  |  High: \(\$r|cnt(\"HIGH\"))  |  Medium: \(\$r|cnt(\"MEDIUM\"))  |  Low: \(\$r|cnt(\"LOW\"))"
          ')"
          echo "$kpis" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

          # 8a) Critical-only table
          echo "### Critical CVEs" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

          crit_rows="$(printf '%s\n' "$rows_json" | jq -r '
            . | map(select(.sev=="CRITICAL"))
              | sort_by(-.rank, .pkg, .cve)
              | .[]
              | "| \(.pkg) | \(.ver) | \(.cve) | \(.sev) | \(.fixed) |"
          ')"

          if [ -z "$crit_rows" ]; then
            echo "_No Critical CVEs found._" >> "$GITHUB_STEP_SUMMARY"
          else
            {
              echo "| Package | Version | CVE | Severity | Fixed |"
              echo "|---|---|---|---|---|"
              printf "%s\n" "$crit_rows"
            } >> "$GITHUB_STEP_SUMMARY"
          fi

          echo "" >> "$GITHUB_STEP_SUMMARY"

          # 8b) All CVEs ordered by severity
          echo "### All CVEs (ordered by severity)" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

          all_rows="$(printf '%s\n' "$rows_json" | jq -r '
            . | sort_by(-.rank, .pkg, .cve)
              | .[]
              | "| \(.pkg) | \(.ver) | \(.cve) | \(.sev) | \(.fixed) |"
          ')"

          if [ -z "$all_rows" ]; then
            echo "_No CVEs found._" >> "$GITHUB_STEP_SUMMARY"
          else
            {
              echo "| Package | Version | CVE | Severity | Fixed |"
              echo "|---|---|---|---|---|"
              printf "%s\n" "$all_rows"
            } >> "$GITHUB_STEP_SUMMARY"
          fi

          echo "" >> "$GITHUB_STEP_SUMMARY"

          # 8c) Collapsible: Grouped by package
          echo "<details>" >> "$GITHUB_STEP_SUMMARY"
          echo "<summary><strong>Findings grouped by Package</strong> (click to expand)</summary>" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

          printf '%s\n' "$rows_json" | jq -r '
            . as $r
            | group_by(.pkg + "@" + .ver)
            | map({
                pkg: (.[0].pkg),
                ver: (.[0].ver),
                count: length,
                items: (sort_by(-.rank, .cve))
              })
            | .[]
            | "<br/>\n<strong>\(.pkg)@\(.ver)</strong> — \(.count) issue(s)\n\n"
              + "| CVE | Severity | Fixed |\n|---|---|---|\n"
              + ( .items | map("| \(.cve) | \(.sev) | \(.fixed) |") | join("\n") )
              + "\n"
          ' >> "$GITHUB_STEP_SUMMARY"

          echo "</details>" >> "$GITHUB_STEP_SUMMARY"
